{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LeetCode Style Practice","text":""},{"location":"#tips-for-identifying-problem-type","title":"Tips for Identifying Problem Type:","text":"<p>To quickly identify the required approach for solving a coding problem, follow this structured thought process:  </p>"},{"location":"#1-understand-the-problem-type","title":"1. Understand the Problem Type","text":"<ul> <li>Graph: Mentions nodes, edges, shortest path \u2192 BFS/DFS, Dijkstra, Union-Find </li> <li>Tree: Involves hierarchical relationships \u2192 Recursion, DFS, BFS, DP on Trees </li> <li>Dynamic Programming (DP):  </li> <li>Optimal substructure (solution builds on smaller subproblems)  </li> <li>Overlapping subproblems (same subproblems repeat)  </li> <li>Keywords: \"ways to do X,\" \"minimum/maximum,\" \"count paths,\" \"partition\"  </li> </ul> <p>Greedy:   - Looks for an immediate best choice at each step   - Keywords: \"maximize,\" \"minimum cost,\" \"smallest/largest\"  </p> <p>Recursion / Backtracking:   - Involves trying multiple possibilities (e.g., permutations, subsets)   - Keywords: \"generate all possible,\" \"find all solutions\"  </p> <p>Sliding Window / Two Pointers:   - Subarray problems, optimizing over contiguous elements   - Keywords: \"longest,\" \"shortest,\" \"smallest subarray,\" \"fixed/variable window\"  </p> <p>Sorting + Binary Search:   - Involves searching efficiently over a sorted dataset   - Keywords: \"find in sorted,\" \"upper/lower bound,\" \"minimum X for condition Y\"  </p> <p>Bit Manipulation:   - Works directly on bits (XOR, AND, OR)   - Keywords: \"bitwise,\" \"parity,\" \"toggle,\" \"power of two\"  </p>"},{"location":"#2-identify-constraints","title":"2. Identify Constraints","text":"<ul> <li>Small <code>n</code> (~20\u201330)? \u2192 Backtracking / Recursion (Exponential OK) </li> <li>Large <code>n</code> (\u226510\u2076)? \u2192 O(log n) or O(n) required (Binary Search, DP, or Greedy) </li> </ul>"},{"location":"#3-look-for-patterns-in-examples","title":"3. Look for Patterns in Examples","text":"<ul> <li>Does the problem break into subproblems? \u2192 DP </li> <li>Can you make local greedy choices? \u2192 Greedy </li> <li>Does it ask for a shortest path? \u2192 Graph BFS/Dijkstra </li> <li>Does it involve arranging elements? \u2192 Sorting / Two Pointers </li> </ul>"},{"location":"#4-recognize-recurrence-state","title":"4. Recognize Recurrence &amp; State","text":"<ul> <li>If a problem depends on previous results, define states \u2192 Use DP </li> <li>If choices at each step don\u2019t affect future choices \u2192 Use Greedy </li> </ul> <p>By practicing problem classification and recognizing patterns, you can instantly identify the best approach! \ud83d\ude80</p>"},{"location":"dp/","title":"Dynamic Programming","text":"<p>Dynamic Programming (DP) is a method for solving complex problems by breaking them down into simpler subproblems.  It is mainly used to solve optimization problems.</p>"},{"location":"dp/#problem","title":"Problem:","text":"<p>The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence goes 0, 1, 1, 2, 3, 5, 8, 13, and so on.</p> <p>Write a function fibonacci(n) that returns the nth number in the Fibonacci sequence.</p>"},{"location":"dp/#example-fibonacci-sequence","title":"Example: Fibonacci Sequence","text":"<p>The recursive formula to compute the Fibonacci sequence is as follows: \\(F_n = F(n-1) + F(n-2)\\).</p>"},{"location":"dp/#why-is-this-a-dynamic-programming-problem","title":"Why is this a Dynamic Programming Problem?","text":"<p>This problem is a classic example of overlapping subproblems, which is a key indicator that Dynamic Programming can optimize the solution.</p> <ul> <li> <p>Overlapping subproblems: To compute fibonacci(5), you need to compute fibonacci(4) and fibonacci(3). But in the recursive approach, fibonacci(4) and fibonacci(3) will be recalculated multiple times.</p> </li> <li> <p>Optimal substructure: The Fibonacci sequence exhibits optimal substructure since the solution to the problem (fibonacci(n)) depends on the solutions to the smaller subproblems (fibonacci(n-1) and fibonacci(n-2)).</p> </li> </ul> <p>By storing the intermediate results of the subproblems we can avoid redundant calcualtions. This is done through memoization (storing results in a cache) or tabulation (building up solutions in an iterative manner)</p>"},{"location":"dp/#dynamic-programming-solution-tabulation-approach","title":"Dynamic Programming Solution (Tabulation Approach)","text":"<pre><code>def fibonacci(n):\n    if n &lt;= 1:\n        return n\n\n    # create a table to store Fibonacci values\n    dp = [0] * (n + 1)\n\n    # base cases\n    dp[0] = 0\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n</code></pre>"},{"location":"dp/#explanation-of-tabulation-soliution","title":"Explanation of Tabulation Soliution:","text":"<ol> <li>Base Case: If n is 0 or 1 return n, because these are given as the first two numbers of the sequence.</li> <li>DP Array: Create an array <code>dp</code> to store Fibonacci numbers from <code>0</code> to <code>n</code>. Initialize the frist two values of the array: <code>dp[0]=0</code> and <code>dp[1]=1</code>.</li> <li>Iterative Solution: Use a loop to fill the array for values from <code>2</code> to <code>n</code>. The value of each Fibonacci number is calculated as the  sum of the two previous numbers <code>dp[i] = dp[i-1] + dp[i-2]</code></li> <li>Return the result: finally, return <code>dp[n]</code> which contains the nth Fibonacci Number.</li> </ol>"},{"location":"dp/#time-complexity","title":"Time Complexity:","text":"<p><code>O(n)</code> as we only need to compute each Fibonacci number once and store it in the array</p>"},{"location":"dp/#space-complexity","title":"Space Complexity:","text":"<p><code>O(n)</code> due to the storage of the Fibonacci sequence in an array of size <code>n+1</code>.</p>"}]}